{
  "hash": "fff8bcdf1340a6e13463da1c9b2eb65f",
  "result": {
    "markdown": "---\ntitle: \"Tweet Analytics for Disaster and Calamity Management\"\nsubtitle: \"INFO 523 - Fall 2023 - Project Final\"\nauthor: \"The Algo-Rythms Team : Visalakshi Prakash Iyer, Himanshu Nimbarte, Shakir Ahmed, Avikal Singh, Poojitha Pasala\"\ntitle-slide-attributes:\n  data-background-image: images/slide_background.jpg\n  data-background-size: stretch\n  data-background-opacity: \"0.7\"\n  data-slide-number: none\nformat:\n  revealjs:\n    theme:  ['data/customtheming.scss']\n    transition: slide\n    background-transition: fade\n    logo: images\\twitter_logo.png\n    footer: \"[ðŸ•Š The Algo-Rhythms](https://info-523-exercises.github.io/project-final-The-Algo-Rhythms/)\"\n    scrollable: true\n    style: |\n      body {\n        font-size: 12px; /* Set your desired font size here */\n      }\n  \neditor: visual\nexecute:\n  echo: false\n---\n\n\n\n\n## Introduction: {.smaller}\n\n-   In times of disasters, individuals frequently turn to social media platforms to communicate information regarding required aid or incidents.\n\n-   Twitter provides an unprecedented opportunity to access a vast amount of information and gain insights directly from those affected by disasters. Harnessing of Twitter's potential is crucial to enhance disaster response and ensure public safety in critical situations.\n\n## Goal and problem statement: {.smaller}\n\n-   **Goal-** In the face of dynamic disasters, a proactive approach to information is essential. Traditional methods can lag, hampering swift responses and resource allocation. Validating Twitter-shared information is critical to prevent panic and confusion among affected communities.\n\n-   **Problem statement-** Conduct classification on tweets during crisis, validate tweets, and deliver accurate information to disaster management teams, thereby contributing to the smooth functioning of rescue operations and boosting the safety and resilience of communities during critical events.\n\n## Execution of plan: {.smaller}\n\n1.  **Created a new streaming pipeline-** Used NTscraper to create a Nitter object which uses Beautiful soup in the back end to fetch tweet details such as \"text\", \"username\" and statistics such as \"likes\",\"comments\" and \"retweets\".\n2.  **Model building-** Used LSTM model to build a fake news classification model and give us the relevant and important details corresponding to disaster management.\n3.  **Model training-** Used Kaggle dataset to perform model training and get accuracy scores.\n4.  **Model testing-** Use real time data based on hashtag- \"#forestfire\" and location set to near \"USA\".\n5.  **GUI creation-** Integrate a search bar for input of hashtag, after which the model fetches the data and performs classification. The classified real tweets are displayed with tweet link, location (if available) and the user.\n\n## Data: {.smaller}\n\n-   Twitter API enables developers to fetch tweets in real-time using keywords. Since the previous month, twitter had revoked the access to pull tweets in free tier.\n\n-   To get the Real-time tweets, we resorted to creating and utilizing a Nitter instance from a web-scraping based package. The tweets are fetched based on type of disaster (hashtag) and location.\n\n-   These tweets will be then analysed in real-time, annotated with insights generated from our modeling process\n\n-   The modeling required Fake Tweet Classification dataset from kaggle is used for classification of tweets as real or fake.\n\n-   The model trained on this dataset was utilized for classifying and segregating the tweets to filter out spotlight tweets.\n\nOur analysis plan involved exploring the dataset for suitability of the training. The insights will be shown in the next slides\n\n## Pie Chart:\n\n::: {.columns .smaller}\n::: {.column .small-font width=\"30%\"}\nThis is the target variable distribution of training dataset. With a fairly even distribution, our model had a high chance of reliable training outcomes.\n:::\n\n::: {.column width=\"70%\"}\n![](images/Pie%20chart.png){fig-align=\"center\"}\n:::\n:::\n\n## Bar Plot:\n\n::: {.columns .smaller}\n::: {.column .small-font width=\"30%\"}\nThe main unique keywords that fall under the tweets tagged as \"disaster tweets\" has the following distribution. It is evident that tweets that talk about the disaster have really focuses terms according to the disaster.\n:::\n\n::: {.column width=\"70%\"}\n![](images/Target%20distribution.jpg){fig-align=\"center\"}\n:::\n:::\n\n## Density Plot:\n\n::: {.columns .smaller}\n::: {.column .small-font width=\"30%\"}\nWith both distribution of the categories not being significantly different from an ideal normal distribution, we had the notion that the model will receive sufficient learning tokens\n:::\n\n::: {.column width=\"70%\"}\n![](images/Unique%20word%20count%20distribution.jpg){fig-align=\"center\"}\n:::\n:::\n\n## Word Cloud:\n\n::: {.columns .smaller}\n::: {.column .small-font width=\"40%\"}\nThis is the wordcloud from the combined tweets of the dataset, for the \"disaster\" class.\n:::\n\n::: {.column width=\"60%\"}\n![](images/Disaster_word_cloud.png){fig-align=\"center\" width=\"65%\"}\n:::\n:::\n\n# Training Outcomes\n\n## BERT {.smaller}\n\n-   First the dataset tweets were broken down through tokenization. These tokens can be individual words or subwords, phrases, or even characters, depending on the specific tokenization technique used. The primary goal of tokenization is to facilitate natural language processing tasks by converting textual data into a format that can be easily handled by algorithms and models.\n\n-   Training BERT was computationally expensive, and well as memory intensive. The accuracy score for BERT was 97% on training and 82% on testing.\n\n## LSTM {.smaller}\n\n-   LSTM on the other hand was not memory intensive, although it was fairly heavy to train, it was able to achieve a great learning curve. It achieved a training accuracy of 83% and testing accuracy of 80%.\n\n-   When both the models were tested on the real-time set, LSTM provided better results compared to BERT. Owing to the fact that some fake tweets which contain the main keywords, can be misclassified due to the attention mechanism.\n\n# Outcome\n\n## Results: {.smaller}\n\nhash_earthquake:\n\n![](images/hashtag_earthquake.png)\n\n## Results:\n\nhash_flood:\n\n![](images/hashtag_flood.JPG)\n\n## Results:\n\nhash_hurricane:\n\n![](images/hashtag_hurricane.JPG)\n\n## Live Demo: {.smaller}\n\nNow, we are going to demonstrate our project in action.\n\n[GUI for Disaster Tweet Analysis](https://disaster-tweet-app-algorhythms.streamlit.app/)\n\n## Challenges Faced {.smaller}\n\n-   We were not able to get access to fetch tweets with twitter developer API, because of the revoked access of free tier developers. This was later improvised using a web scraping object\n\n-   There were a greater need for computational power, as text based models are computationally heavy. We utilized online resources and GPU to train the model and load them.\n\n-   Response time is a greater requirement when it comes to tools like disaster monitoring systems. With heavy models running in the background, memory optimization and caching plays a great role.\n\n## Conclusion: {.smaller}\n\n-   It has been a constant effort of the developer community to utilize twitter and generate analysis to manage/monitor disasters. However, there are some challenges when considering social media as an information source for disaster response. In particular, social media streams contain large amounts of irrelevant messages such as rumors, advertisements, or even misinformation.\n\n-   This project is an improvement to previously attempted disaster tweet monitoring systems hosted by Google (Tensorflow and Kaggle competitions). What we achieved on top of the previous attempts, is the improved model scores and higher analytic insights on the location tracking.\n\n-   This particular attempt can serve as a derivation for improve intelligence received during a crisis, and can enable intelligent officers to access calls for help quickly.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}